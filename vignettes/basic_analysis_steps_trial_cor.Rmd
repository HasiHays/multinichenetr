---
title: "Multi-Sample Multi-condition Cell-Cell Communication Analysis via NicheNet: HNSCC application; All-vs-All"
author: "Robin Browaeys"
date: "2021-04-09"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multi-Sample Multi-condition Cell-Cell Communication Analysis via NicheNet: HNSCC application; All-vs-All}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- github markdown built using 
rmarkdown::render("vignettes/basic_analysis_steps.Rmd", output_format = "github_document")
-->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  # comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

In this vignette, you can learn how to perform an all-vs-all MultiNicheNet analysis. In this vignette, we start from one single Seurat object containing cells from both sender and receiver cell types and from different patients.

A MultiNicheNet analysis can be performed if you have multi-sample, multi-group single-cell data. MultiNicheNet will look for cell-cell communication between the cell types in your data for each sample, and compare the cell-cell communication patterns between the groups of interest. Therefore, the absolute minimum of meta data you need to have, are following columns indicating for each cell: the **group**, **sample** and **cell type**.
 
As example expression data of interacting cells, we will use data from Puram et al. to explore intercellular communication in the tumor microenvironment in head and neck squamous cell carcinoma (HNSCC) [See @puram_single-cell_2017] [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.4675430.svg)](https://doi.org/10.5281/zenodo.4675430).  More specifically, we will look at differential cell-cell communication patterns between tumors scoring high for a partial epithelial-mesenschymal transition (p-EMT) program vs low-scoring tumors.

In this vignette, we will prepare the data and analysis parameters, and then perform the MultiNicheNet analysis. 

The different steps of the MultiNicheNet analysis are the following:

* 0. Preparation of the analysis: load packages, NicheNet LR network & ligand-target matrix, single-cell expression data, and define main settings of the MultiNicheNet analysis

* 1. Extract cell type abundance and expression information from receiver and sender cell types, and link this expression information for ligands of the sender cell types to the corresponding receptors of the receiver cell types 

* 2. Perform genome-wide differential expression analysis of receiver and sender cell types to define DE genes between the conditions of interest. Based on this analysis, we can define the logFC/p-value of ligands in senders and receptors in receivers, and define the set of affected target genes in the receiver.

* 3. Predict NicheNet ligand activities and NicheNet ligand-target links based on these differential expression results

* 4. Use the information collected above to prioritize all sender-ligand---receiver-receptor pairs.

* 5. Optional: unsupervised analysis of sender-ligand---receiver-receptor pair expression values per sample, to see heterogeneity in cell-cell communication. 

In this vignette, we will demonstrate all these steps in detail.

After the MultiNicheNet analysis is done, we will explore the output of the analysis with different ways of visualization. 

# Step 0: Preparation of the analysis: load packages, NicheNet LR network & ligand-target matrix, single-cell expression data

## Step 0.1: Load required packages and NicheNet ligand-receptor network and ligand-target matrix

```{r}
library(Seurat)
library(dplyr)
library(ggplot2)
library(multinichenetr)
```

```{r}
# LR network
lr_network = readRDS(url("https://zenodo.org/record/3260758/files/lr_network.rds"))
lr_network = lr_network %>% filter(! database %in% c("ppi_prediction","ppi_prediction_go")) # We filter out these interactions because they are not really bona-fide LR pairs - NicheNet v2 prior models will be released relatively soon
lr_network = lr_network %>% dplyr::rename(ligand = from, receptor = to) %>% distinct(ligand, receptor)
```

```{r}
ligand_target_matrix = readRDS(url("https://zenodo.org/record/3260758/files/ligand_target_matrix.rds"))
```

## Step 0.2: Prepare Seurat Objects for Sender and Receiver cells

In this vignette, sender and receiver cell types are in the same Seurat object, which we will load here.

In this case study, we want to study differences in cell-cell communication patterns between pEMT-high and pEMT-low tumors. The meta data columns that indicate the pEMT status of tumors are 'pEMT' and 'pEMT_fine', cell type is indicated in the 'celltype' column, and the sample is indicated by the 'tumor' column. 

__User adaptation required__
```{r}
seurat_obj = readRDS(url("https://zenodo.org/record/4675430/files/seurat_obj_hnscc.rds"))
DimPlot(seurat_obj, group.by = "celltype")
DimPlot(seurat_obj, group.by = "tumor")
DimPlot(seurat_obj, group.by = "pEMT")
DimPlot(seurat_obj, group.by = "pEMT_fine")
```

We will now also check the number of cells per cell type condition combination, and the number of patients per condition.

__User adaptation required__
```{r}
table(seurat_obj@meta.data$celltype, seurat_obj@meta.data$tumor) # cell types vs samples
table(seurat_obj@meta.data$celltype, seurat_obj@meta.data$pEMT) # cell types vs conditions
table(seurat_obj@meta.data$tumor, seurat_obj@meta.data$pEMT) # samples vs conditions
```

As you can see, some Celltype-Sample combinations have 0 cells. It is possible that during DE analysis, some cell types will be removed from the analysis if there is not enough information to do a DE analysis. (More info later)

## Step 0.3: Prepare settings of the MultiNicheNet cell-cell communication analysis

### Define in which metadata columns we can find the **group**, **sample** and **cell type** IDs

For the group_id, we now choose for the 'pEMT' column instead of 'pEMT_fine', which we will select in a subsequent analysis.

__User adaptation required__
```{r}
sample_id = "tumor"
group_id = "pEMT"
celltype_id = "celltype"
```

Sender and receiver cell types also need to be defined. Both are here all cell types in the dataset because we are interested in an All-vs-All analysis.

```{r}
senders_oi = seurat_obj@meta.data[,celltype_id] %>% unique()
receivers_oi = seurat_obj@meta.data[,celltype_id] %>% unique()
```

If the user wants it, it is possible to use only a subset of senders and receivers. Senders and receivers can be entirely different, but also overlapping, or the same. If you don't use all the cell types in your data, we recommend to continue with a subset of your data.

Example code:
```{r}
subset_senders_receivers = FALSE
if(subset_senders_receivers == TRUE){
  senders_oi = seurat_obj@meta.data[,celltype_id] %>% unique() %>% .[1:2]
  receivers_oi = seurat_obj@meta.data[,celltype_id] %>% unique() %>% .[2:4]
  seurat_obj = seurat_obj %>% subset(subset = celltype %in% c(senders_oi, receivers_oi))
}
```

Now we will go to the first real step of the MultiNicheNet analysis

# Step 1: Extract cell type abundance and expression information from receiver and sender cell types, and link this expression information for ligands of the sender cell types to the corresponding receptors of the receiver cell types

Since MultiNicheNet will infer group differences at the sample level for each cell type (currently via Muscat and pseudobulking), we need to have sufficient cells per sample of a cell type, and this for both groups. In the following analysis we will set this minimum number of cells per cell type per sample at 5. For 10x scRNAseq datasets, we recommend to set this to 10.

__User adaptation recommended__
```{r}
min_cells = 5
```

Now we will calculate abundance and expression information for each cell type / sample / group combination with the following functions. In the output of this function, you can also find some 'Cell type abundance diagnostic plots' that will the users which celltype-sample combinations will be left out later on for DE calculation because the nr of cells is lower than de defined minimum defined here above. If too many celltype-sample combinations don't pass this threshold, we recommend to define your cell types in a more general way (use one level higher of the cell type ontology hierarchy) (eg TH17 CD4T cells --> CD4T cells).

```{r}
abundance_expression_info = get_abundance_expression_info(seurat_obj = seurat_obj, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, min_cells = min_cells, senders_oi = senders_oi, receivers_oi = receivers_oi, lr_network = lr_network)
```

First, check the cell type abundance diagnostic plots.

### Interpretation of cell type abundance information

The first plot visualizes the number of cells per celltype-sample combination, and indicates which combinations are removed during the DE analysis because there are less than `min_cells` in the celltype-sample combination. 

```{r, fig.width=15, fig.height=12}
abundance_expression_info$abund_plot_sample
```
The red dotted line indicates the required minimum of cells as defined above in `min_cells`. We can see here that quite many sample-celltype combinations are left out. For Endothelial, Myeloid, and T cells, we don't even have two or more samples that have enough cells of those cell types. Therefore, those cell types were removed before the DE analysis. As stated before when seeing this, we would recommend to use a higher-level cell type annotation if possible. But the annotation here is already high-level, and grouping Endothelial cells, T cells and Myeloid cells eg would not make sense biologically. That we won't be able to include these cell types in our analysis is a limitation of the MultiNicheNet approach compared to classic cell-level-based approaches, but on the contrary, those cell-level-based approaches don't reveal the lack of cells in many samples, and might lead to biased results. Another limitation is that we lose now potentially very important group-specific cell types, like T cells in this case. To overcome this, we will use a hack later on. TODODODOODDOODODODODODODOD

In a next plot, we will look at differential abundance between the conditions. This because the pseudobulking approach behind Muscat could potentially suffer from some biases if there would be huge differences in abundances of a cell type between different groups. Downstream results of these cell types should then be considered with some caution.

```{r, fig.width=7, fig.height=7}
abundance_expression_info$abund_plot_group
```
Differential abundance looks quite OK for the cell types kept for the DE analysis (i.e. CAF, Malignant and myofibroblast)

If you want to look at the cell numbers behind these plots, you can do so via the following piece of code

```{r}
abundance_expression_info$abundance_data_receiver
abundance_expression_info$abundance_data_sender # in the case of an all-vs-all analysis: both are the same
```

__Important__: Based on the cell type abundance diagnostics, we recommend users to change their analysis settings if required, before proceeding with the rest of the analysis.

### Interpretation of expression information

Previously, we also calculated expression information. With the following piece of code, you can check the average expression for each gene per sample (normalized expression value and fraction of expressing cells with non-zero counts). 

```{r}
abundance_expression_info$celltype_info$avg_df
abundance_expression_info$celltype_info$frq_df
```

Now for the average per group:

```{r}
abundance_expression_info$celltype_info$avg_df_group
abundance_expression_info$celltype_info$frq_df_group
```

In the last part of this step, we combined this information for each ligand-receptor pair combination for each sender-receiver combination. The output of this can be seen as well:

For sample-based:

```{r}
abundance_expression_info$sender_receiver_info$avg_df
abundance_expression_info$sender_receiver_info$frq_df
```

For group-based:

```{r}
abundance_expression_info$sender_receiver_info$avg_df_group
abundance_expression_info$sender_receiver_info$frq_df_group
```

# Step 2: Perform genome-wide differential expression analysis of receiver and sender cell types to define DE genes between the conditions of interest. Based on this analysis, we can define the logFC/p-value of ligands in senders and receptors in receivers, and define the set of affected target genes in the receiver.

Now we will go over to the multi-group, multi-sample differential expression (DE) analysis (also called 'differential state' analysis by the developers of Muscat).

### Define the contrasts and covariates of interest for the DE analysis.

Here, we want to compare the p-EMT-high vs the p-EMT-low group and find cell-cell communication events that are higher in high than low pEMT. We don't have other covariates to correct for in this dataset. If you would have covariates you can correct for (meaning: different covariate values should be present in all your groups of interest as defined in the contrasts), we strongly recommend doing this, since this is one of the main unique possibilities of the MultiNicheNet approach.

Note the format to indicate the contrasts! (This formatting should be adhered to very strictly, and white spaces are not allowed)

__User adaptation required__
```{r}
covariates = NA
contrasts_oi = c("'High-Low','Low-High'")
contrast_tbl = tibble(contrast = 
                        c("High-Low","Low-High"), 
                      group = c("High","Low"))
```

### Perform the DE analysis for each cell type.

```{r}
DE_info = get_DE_info(seurat_obj = seurat_obj, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells)

# try once with limma-trend on the average
# DE_info = get_DE_info(seurat_obj = seurat_obj, sample_id = sample_id, group_id = group_id, celltype_id = celltype_id, covariates = covariates, contrasts_oi = contrasts_oi, min_cells = min_cells, fun_oi_pb = "mean", de_method_oi = "limma-trend")
```

### Check DE results

Table with logFC and p-values for each gene-celltype-contrast:

```{r}
DE_info$celltype_de$de_output_tidy
```

Diagnostic p-value histograms:

```{r, fig.width=9, fig.height=6}
DE_info$hist_pvals
```
(Note: this p-value histograms are the same for High-Low and Low-High because we only have two groups and compare them to each other - a DE gene in one comparison will then also be DE in the other comparison, with just a reversed sign of the logFC)

In order to trust the p-values, the p-value distributions should be uniform distributions, with a peak allowed between 0 and 0.05 if there would be a clear biological effect in the data. This clear effect (=clear DE) seems to be present here in the Malignant cell type populations, although the histogram is not very uniformly distributed for p-values between 0.05 and 0.25. This might point to issues in the DE model definition (eg we did not add all important covariates, substructure present,...)

Because there might be some issues, and we anticipate this could be present in other datasets, we will now use the empiricall null procedure. This is a procedure that will define empirical p-values based on the observed distribution of the test statistic (here: logFC) and not based on the theoretical distribution. We only recommend this if the p-value distributions point to possible issues. ([ADD REFERENCE])

### Empirical Null procedure

__User adaptation recommended__
```{r}
empirical_pval = TRUE
if(empirical_pval == TRUE){
  DE_info_emp = get_empirical_pvals(DE_info$celltype_de$de_output_tidy)
} 
```

Table with logFC and p-values for each gene-celltype-contrast:

```{r}
DE_info_emp$de_output_tidy_emp
```

The following plot shows those corrected, empirical p-values:

```{r, fig.width=9, fig.height=6}
DE_info_emp$hist_pvals_emp
```
The following plots show how well the correction worked. The green fitted curve should fit well with the histogram. If not, this might point to some issues in the DE model definition.

__User adaptation required__
```{r, fig.width=7, fig.height=7}
DE_info_emp$z_distr_plots_emp_pval
```
(Note: if plotting does not work, it might be necessary to run these plot commands in the console)

In general, these plots looks fine, except for the Malignant cells. As discussed in the previous plots: there might be an issue here. One possible explanation might be that there is additional substructure in the data. This could make sense because the pEMT high group consists both of pEMT very-high and pEMT high samples according to the finer subdivision/metadata column `pEMT_fine`. Another reason for the possible substructure: malignant cells of each tumor are very different because of genetic aberrations.

If we compare the empirical p-values to the original ones before for the malignant cells, we see that through the empirical null procedure, we lost some DE genes in malignant cells. But it is likely that the DE genes that er kept are the most bona fide ones.

As additional check, we will look for the concordance between p-values rankings of the original and empirical DE analysis (via ranking-line and upset plots):

```{r}
comparison_plots = DE_info$celltype_de$de_output_tidy$cluster_id %>% unique() %>% lapply(function(celltype_oi, adjusted = FALSE){
  if(adjusted == TRUE){
      de_genes_normal = DE_info$celltype_de$de_output_tidy %>% filter(cluster_id == celltype_oi) %>% filter(p_adj.glb <= 0.05) %>% pull(gene) %>% unique()
      de_genes_emp = DE_info_emp$de_output_tidy_emp %>% filter(cluster_id == celltype_oi) %>% filter(p_adj_emp <= 0.05) %>% pull(gene) %>% unique()

  } else {
      de_genes_normal = DE_info$celltype_de$de_output_tidy %>% filter(cluster_id == celltype_oi) %>% filter(p_val <= 0.05) %>% pull(gene) %>% unique()
      de_genes_emp = DE_info_emp$de_output_tidy_emp %>% filter(cluster_id == celltype_oi) %>% filter(p_emp <= 0.05) %>% pull(gene) %>% unique()

  }

  upset_df = tibble(gene = union(de_genes_normal, de_genes_emp), normal = as.double(gene %in% de_genes_normal), empirical = as.double(gene %in% de_genes_emp)) %>% data.frame() %>% magrittr::set_rownames(.$gene) %>% dplyr::select(-gene)
  colnames(upset_df) = paste(colnames(upset_df), celltype_oi, sep = "-")
  p_upset = UpSetR::upset(upset_df, sets.bar.color = "#56B4E9", order.by = "freq", empty.intersections = "on") 
  
  p_ranking = DE_info_emp$de_output_tidy_emp %>% filter(gene %in% union(de_genes_normal, de_genes_emp) & cluster_id == celltype_oi) %>% group_by(cluster_id, contrast) %>% mutate(normal = rank(p_val), empirical = rank(p_emp)) %>% filter(normal != empirical) %>% mutate(empirical_lower = empirical < normal) %>% tidyr::gather(rank_type, rank, normal:empirical) %>% dplyr::select(gene, rank_type, rank, empirical_lower)  %>% 
    ggplot(aes(rank_type, rank, group = gene, color = empirical_lower)) + geom_line(aes(group = gene)) + facet_grid(cluster_id ~ contrast) + theme_bw()
  
  return(list(p_upset, p_ranking))
  
}, adjusted = FALSE) 
comparison_plots
```

### Conclusion of the diagnostic plots concerning the DE analysis

P-value histograms of both the normal and empirical p-values indicate there might be some problems in the DE model definition, certainly for malignant cells.
If possible it might be a good idea to include more covariates in the model, or use the `pEMT_fine` group definition instead. 

Because of these issues (that point to violations to the assumptions that should be fulfilled for having accurate theoretical p-values), we decide to continue based on the empirical p-values in this case study. 

__User adaptation recommended__
```{r}
empirical_pval = TRUE
if(empirical_pval == FALSE){
  celltype_de = DE_info$celltype_de$de_output_tidy
} else {
  celltype_de = DE_info_emp$de_output_tidy_emp %>% dplyr::select(-p_val, -p_adj) %>% dplyr::rename(p_val = p_emp, p_adj = p_adj_emp)
}
```

### Combine DE information for ligand-senders and receptors-receivers (similar to step1 - `abundance_expression_info$sender_receiver_info`)

```{r}
sender_receiver_de = combine_sender_receiver_de(
  sender_de = celltype_de,
  receiver_de = celltype_de,
  senders_oi = senders_oi,
  receivers_oi = receivers_oi,
  lr_network = lr_network
)
```

```{r}
sender_receiver_de %>% head(20)
```

# Step 3: Predict NicheNet ligand activities and NicheNet ligand-target links based on these differential expression results

## Define the parameters for the NicheNet ligand activity analysis 

Here, we need to define the thresholds that will be used to consider genes as differentially expressed or not (logFC, p-value, decision whether to use adjusted or normal p-value, minimum fraction of cells that should express a gene in at least one sample in a group, whether to use the normal p-values or empirical p-values). 

NicheNet ligand activity will then be calculated as the enrichment of predicted target genes of ligands in this set of DE genes compared to the genomic background. Here we choose for a minimum logFC of 0.50, maximum p-value of 0.05, and minimum fraction of expression of 0.05. 

__User adaptation recommended__
```{r}
logFC_threshold = 0.50
p_val_threshold = 0.05
fraction_cutoff = 0.05
```

We will here choose for applying the p-value cutoff on the normal p-values, and not on the p-values corrected for multiple testing. This choice was made here because of lack of statistical power due to pseudobulking and the fact that this dataset has only a few samples per group.

__User adaptation recommended__
```{r}
p_val_adj = FALSE 
```

For the NicheNet ligand-target inference, we also need to select which top n of the predicted target genes will be considered (here: top 250 targets per ligand).

__User adaptation recommended__
```{r}
top_n_target = 250
```

The NicheNet ligand activity analysis can be run in parallel for each receiver cell type, by changing the number of cores as defined here. This is only recommended if you have many receiver cell type. 

__User adaptation recommended__
```{r}
verbose = TRUE
n.cores = 1
```

## Run the NicheNet ligand activity analysis 

```{r}
ligand_activities_targets_DEgenes = suppressMessages(suppressWarnings(get_ligand_activities_targets_DEgenes(
  receiver_de = celltype_de,
  receivers_oi = receivers_oi,
  ligand_target_matrix = ligand_target_matrix,
  logFC_threshold = logFC_threshold,
  p_val_threshold = p_val_threshold,
  p_val_adj = p_val_adj,
  top_n_target = top_n_target,
  verbose = verbose, 
  n.cores = n.cores
)))
```

Check the DE genes used for the activity analysis
```{r}
ligand_activities_targets_DEgenes$de_genes_df %>% head(20)
```

Check the output of the activity analysis
```{r}
ligand_activities_targets_DEgenes$ligand_activities %>% head(20)
```

# Step 4: Use the information collected above to prioritize all sender-ligand---receiver-receptor pairs.

In the 3 previous steps, we calculated expression, differential expression and NicheNet activity information. Now we will combine these different types of information in one prioritization scheme.

MultiNicheNet allows the user to define the weights of the following criteria to prioritize ligand-receptor interactions:

* Upregulation of the ligand in a sender cell type and/or upregulation of the receptor in a receiver cell type - in the condition of interest. : `scaled_lfc_ligand`, `scaled_p_val_ligand`, `scaled_lfc_receptor`, and `scaled_p_val_receptor`
* Sufficiently high expression levels of ligand and receptor in many samples of the same group (to mitigate the influence of outlier samples). : `fraction_expressing_ligand_receptor`
* Cell-type and condition specific expression of the ligand in the sender cell type and receptor in the receiver cell type (to mitigate the influence of upregulated but still relatively weakly expressed ligands/receptors) : `scaled_avg_exprs_ligand`,  `scaled_avg_frq_ligand`,  `scaled_avg_exprs_receptor`,  and `scaled_avg_frq_receptor`
* High NicheNet ligand activity, to further prioritize ligand-receptor pairs based on their predicted effect of the ligand-receptor interaction on the gene expression in the receiver cell type : `scaled_activity` and `scaled_activity_scaled` (scaled_activity=absolute value of ligand activity; scaled_activity_scaled=scaled ligand activity value that is comparable between different receiver settings - recommended to put more weight on this)
* High relative abundance of sender and/or receiver in the condition of interest: `scaled_abundance_sender` and `scaled_abundance_receiver`

The different properties of the sender-ligand---receiver-receptor pairs can be weighted according to the user's preference and insight in the dataset at hand.

## Define the prioritization weights, and prepare grouping objects

We will set our preference for this dataset as follows:

__User adaptation recommended__
```{r}
prioritizing_weights_DE = c("de_ligand" = 3,
                         "de_receptor" = 3)
prioritizing_weights_activity = c("activity_scaled" = 3)

prioritizing_weights_expression_specificity = c("exprs_ligand" = 1.5,
                         "exprs_receptor" = 1.5)

prioritizing_weights_expression_sufficiency = c("frac_exprs_ligand_receptor" = 2)

prioritizing_weights_relative_abundance = c( "abund_sender" = 0,
                         "abund_receiver" = 0)


```

```{r}
prioritizing_weights = c(prioritizing_weights_DE, 
                         prioritizing_weights_activity, 
                         prioritizing_weights_expression_specificity,
                         prioritizing_weights_expression_sufficiency, 
                         prioritizing_weights_relative_abundance)
```

Make necessary grouping data frame

```{r}
sender_receiver_tbl = sender_receiver_de %>% dplyr::distinct(sender, receiver)

metadata_combined = seurat_obj@meta.data %>% tibble::as_tibble()

if(!is.na(covariates)){
  grouping_tbl = metadata_combined[,c(sample_id, group_id, covariates)] %>% tibble::as_tibble() %>% dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group",covariates)
} else {
  grouping_tbl = metadata_combined[,c(sample_id, group_id)] %>% tibble::as_tibble() %>% dplyr::distinct()
  colnames(grouping_tbl) = c("sample","group")
}

```

Crucial note: grouping_tbl: group should be the same as in the contrast_tbl, and the expression ino tables! Rename accordingly if this would not be the case. If you followed the guidelines of this tutorial closely, there should be no problem.

## Run the prioritization 

```{r}
prioritization_tables = suppressMessages(generate_prioritization_tables(
  sender_receiver_info = abundance_expression_info$sender_receiver_info,
  sender_receiver_de = sender_receiver_de,
  ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
  contrast_tbl = contrast_tbl,
  sender_receiver_tbl = sender_receiver_tbl,
  grouping_tbl = grouping_tbl,
  prioritizing_weights = prioritizing_weights,
  fraction_cutoff = fraction_cutoff, 
  abundance_data_receiver = abundance_expression_info$abundance_data_receiver,
  abundance_data_sender = abundance_expression_info$abundance_data_sender
))
```

Check the output tables

First: group-based summary table

```{r}
prioritization_tables$group_prioritization_tbl %>% head(20)
```

Second: sample-based summary table: contains expression information of each LR pair per sample

```{r}
prioritization_tables$sample_prioritization_tbl %>% head(20)
```

# Step 5: Optional: unsupervised analysis of sender-ligand---receiver-receptor pair expression values per sample, to see heterogeneity in cell-cell communication. 

__User adaptation recommended__
```{r}
return_lr_prod_matrix = TRUE
if(return_lr_prod_matrix == TRUE){

  ids_oi = prioritization_tables$group_prioritization_tbl %>% dplyr::filter(fraction_expressing_ligand_receptor > 0)  %>% dplyr::pull(id) %>% unique()
  
  lr_prod_df = abundance_expression_info$sender_receiver_info$avg_df %>% dplyr::inner_join(grouping_tbl, by = "sample") %>% dplyr::mutate(lr_interaction = paste(ligand, receptor, sep = "_")) %>% dplyr::mutate(id = paste(lr_interaction, sender, receiver, sep = "_")) %>% dplyr::select(sample, id, ligand_receptor_prod) %>% dplyr::filter(id %in% ids_oi) %>% dplyr::distinct() %>% tidyr::spread(id, ligand_receptor_prod)
  lr_prod_mat = lr_prod_df %>% dplyr::select(-sample) %>% data.frame() %>% as.matrix()
  rownames(lr_prod_mat) = lr_prod_df$sample
  
  col_remove = lr_prod_mat %>% apply(2,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
  row_remove = lr_prod_mat %>% apply(1,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
  
  lr_prod_mat = lr_prod_mat %>% .[rownames(.) %>% generics::setdiff(col_remove),colnames(.) %>% generics::setdiff(col_remove)]
} else {
  lr_prod_mat = NULL
}

```


# Save all the output of MultiNicheNet 

To avoid needing to redo the analysis later.
All the output written down here is sufficient to make all in-built downstream visualizations.

__User adaptation recommended__
```{r}
path = "./"

multinichenet_output = list(
    celltype_info = abundance_expression_info$celltype_info,
    celltype_de = celltype_de,
    sender_receiver_info = abundance_expression_info$sender_receiver_info,
    sender_receiver_de =  sender_receiver_de,
    ligand_activities_targets_DEgenes = ligand_activities_targets_DEgenes,
    prioritization_tables = prioritization_tables,
    lr_prod_mat = lr_prod_mat,
    grouping_tbl = grouping_tbl
  ) 
multinichenet_output = multinichenet_output %>% make_lite_output()

save = FALSE
if(save == TRUE){
  saveRDS(multinichenet_output, paste0(path, "multinichenet_output.rds"))

}
```

# Visualization of the results of the cell-cell communication analysis

In a first instance, we will look at the broad overview of prioritized interactions via condition-specific Circos plots.
We will filter on the prioritization score after removing interactions that are not upregulated in the condition of interest, and that are in no patient expressed in more than 5% of cells of a cell type (cf `fraction_cutoff`).

We will look here at the top100 predictions across all contrasts (high vs low; and low vs high), senders, and receivers of interest.

## Circos plot of top-prioritized links

(remark: there are still some bugs in the automatic circos plot function)

```{r, fig.width=15, fig.height=12}
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, ligand, receptor, group, prioritization_score, ligand_receptor_lfc_avg, fraction_expressing_ligand_receptor) %>% 
  filter(ligand_receptor_lfc_avg > 0 & fraction_expressing_ligand_receptor > 0) %>% top_n(100, prioritization_score) 

prioritized_tbl_oi %>% group_by(group) %>% count()

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(id %in% prioritized_tbl_oi$id) %>% 
  distinct(id, sender, receiver, ligand, receptor, group) %>% left_join(prioritized_tbl_oi)
prioritized_tbl_oi$prioritization_score[is.na(prioritized_tbl_oi$prioritization_score)] = 0


n_senders = prioritized_tbl_oi$sender %>% unique() %>% length()
n_receivers = prioritized_tbl_oi$receiver %>% unique() %>% length()

colors_sender = c("red", "orange", "royalblue") %>% magrittr::set_names(prioritized_tbl_oi$sender %>% unique())
colors_receiver = c("red", "orange", "royalblue") %>% magrittr::set_names(prioritized_tbl_oi$receiver %>% unique())

circos_list = make_circos_group_comparison(prioritized_tbl_oi, colors_sender, colors_receiver)

```

## Visualization of scaled_LR_prod per sample

Now we will visualize per sample the scaled product of ligand and receptor expression. Samples that were left out of the DE analysis are indicated with a smaller dot (this helps to indicate the samples that did not contribute to the calculation of the logFC, and thus not contributed to the final prioritization)

We will now check the top75 interactions specific for the pEMT high group

```{r}
group_oi = "High"
```

```{r, fig.height=18, fig.width=12}
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  distinct(id, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_expressing_ligand_receptor,  prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi) %>% group_by(group) %>% top_n(75, prioritization_score) 

plot_oi = make_sample_lr_prod_plots(multinichenet_output$prioritization_tables, prioritized_tbl_oi)
plot_oi
```

Next to these LR expression products, we can also plot the NicheNet ligand activities of the ligand in the receiver.

```{r, fig.height=18, fig.width=18}
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  distinct(id, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_expressing_ligand_receptor,  prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi) %>% group_by(group) %>% top_n(75, prioritization_score) 

plot_oi = make_sample_lr_prod_activity_plots(multinichenet_output$prioritization_tables, prioritized_tbl_oi, widths = c(5,1,1))
plot_oi
```

## Visualization of expression-logFC per group and ligand activity

Next type of plots will show the logFC of LR pairs across all sender-receiver pairs that are selected, and add the ligand activity next to it.

```{r}
receiver_oi = "Malignant"
group_oi = "High"
```

```{r, fig.width=18, fig.height=9}

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_ligand_group, fraction_expressing_ligand_receptor, scaled_avg_exprs_ligand, prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi & receiver == receiver_oi) %>% top_n(75, prioritization_score) 

plot_oi = make_group_lfc_exprs_activity_plot(multinichenet_output$prioritization_tables, prioritized_tbl_oi, receiver_oi, heights = c(5,1,1))
plot_oi

```

## Visualization of ligand-activity, ligand-target links, and target gene expression

In another type of plot, we can visualize the ligand activities for a group-receiver combination, and show the predicted ligand-target links, and also the expression of the predicted target genes across samples.

First: show this for a selection of ligands with high ligand activities:

```{r}
group_oi = "High"
receiver_oi = "Malignant"
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, ligand, receptor, group, prioritization_score, ligand_receptor_lfc_avg, fraction_expressing_ligand_receptor, activity_scaled) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi & receiver == receiver_oi) %>% 
  group_by(group) %>% top_n(50, prioritization_score) %>% top_n(25, activity_scaled) %>% arrange(-activity_scaled)
```

```{r, fig.width=18, fig.height=10}
combined_plot = make_ligand_activity_target_plot(group_oi, receiver_oi, prioritized_tbl_oi, multinichenet_output$ligand_activities_targets_DEgenes, contrast_tbl, multinichenet_output$grouping_tbl, multinichenet_output$celltype_info, plot_legend = FALSE)
combined_plot
```

Now: show this for a selection of ligands with high general prioritization scores, not necessarily high ligand activities.

```{r}
group_oi = "High"
receiver_oi = "Malignant"
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, ligand, receptor, group, prioritization_score, ligand_receptor_lfc_avg, fraction_expressing_ligand_receptor, activity_scaled) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi & receiver == receiver_oi) %>% 
  group_by(group) %>% top_n(25, prioritization_score) %>% arrange(-activity_scaled)
```

```{r, fig.width=18, fig.height=10}
combined_plot = make_ligand_activity_target_plot(group_oi, receiver_oi, prioritized_tbl_oi, multinichenet_output$ligand_activities_targets_DEgenes, contrast_tbl, multinichenet_output$grouping_tbl, multinichenet_output$celltype_info, plot_legend = FALSE)
combined_plot
```

Of course you can look at other receivers as well:

```{r}
group_oi = "High"
receiver_oi = "myofibroblast"
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, ligand, receptor, group, prioritization_score, ligand_receptor_lfc_avg, fraction_expressing_ligand_receptor, activity_scaled) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi & receiver == receiver_oi) %>% 
  group_by(group) %>% top_n(25, prioritization_score) %>% arrange(-activity_scaled)
```

```{r, fig.width=18, fig.height=10}
combined_plot = make_ligand_activity_target_plot(group_oi, receiver_oi, prioritized_tbl_oi, multinichenet_output$ligand_activities_targets_DEgenes, contrast_tbl, multinichenet_output$grouping_tbl, multinichenet_output$celltype_info, plot_legend = FALSE)
combined_plot
```


## Show ligand activities for each receiver-group combination

In the next type of plot, we plot all the ligand activities (Both scaled and absolute activities) of each receiver-group combination. This can give us some insights in active signaling pathways across groups. Note that we can thus show top ligands based on ligand activity - agnostic of expression in sender. 

```{r, fig.width=5, fig.height=8}

ligands_oi = multinichenet_output$prioritization_tables$ligand_activities_target_de_tbl %>% inner_join(contrast_tbl) %>% 
  group_by(group, receiver) %>% distinct(ligand, receiver, group, activity) %>% 
  top_n(5, activity) %>% pull(ligand) %>% unique()

plot_oi = make_ligand_activity_plots(multinichenet_output$prioritization_tables, ligands_oi, contrast_tbl, widths = NULL)
plot_oi

```

Or we can do this plot for ligands, while considering the general priorization score (which considers expression information etc)

Show top ligands based on prioritization scores

```{r, fig.width=5, fig.height=8}

ligands_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  group_by(group, receiver) %>% distinct(ligand, receiver, group, prioritization_score) %>% 
  top_n(5, prioritization_score) %>% pull(ligand) %>% unique()

plot_oi = make_ligand_activity_plots(multinichenet_output$prioritization_tables, ligands_oi, contrast_tbl, widths = NULL)
plot_oi

```

## Zoom in on specific ligand-receptor interactions: show their expression in the single-cell data!

Single-cell-based Nebulosa, Feature, and Violin plots of ligand-receptor interaction of interest: `make_ligand_receptor_nebulosa_feature_plot` and `make_ligand_receptor_violin_plot`

It is often useful to zoom in on specific ligand-receptor interactions of interest by looking in more detail to their expression at the single cell level 

Check the highest scoring links based on the general prioritization score. Here we will pick one of those to visualize.

```{r}
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  filter(fraction_ligand_group > fraction_cutoff & fraction_receptor_group > fraction_cutoff) %>% 
  distinct(id, sender, receiver, ligand, receptor, group, prioritization_score) %>% 
  group_by(group, receiver) %>% top_n(5, prioritization_score) 
prioritized_tbl_oi
```

```{r}
ligand_oi = "DLL1"
receptor_oi = "NOTCH3"
group_oi = "High"
sender_oi = "Malignant"
receiver_oi = "myofibroblast"
```

Nebulosa and Feature plot of the ligand in the sender cell type and the receptor in the receiver cell type (split per condition)

```{r, fig.width=15, fig.height=15}
plot_list = make_ligand_receptor_nebulosa_feature_plot(seurat_obj_sender = seurat_obj, seurat_obj_receiver = seurat_obj, ligand_oi = ligand_oi, receptor_oi = receptor_oi, group_oi = group_oi, group_id = group_id, celltype_id_sender = celltype_id, celltype_id_receiver = celltype_id, senders_oi = c("Malignant","myofibroblast","CAF"), receivers_oi = c("Malignant","myofibroblast","CAF"), prioritized_tbl_oi = prioritized_tbl_oi)
# plot_list$nebulosa # not recommended for Smart-seq data
plot_list$feature
```
Pooled single-cell and sample-specific single-cell violin plots of ligand and receptor expression in respectively sender and receiver.


```{r, fig.width=13, fig.height=8}
plot_list2 = make_ligand_receptor_violin_plot(seurat_obj_sender = seurat_obj, seurat_obj_receiver = seurat_obj, ligand_oi = ligand_oi, receptor_oi = receptor_oi, group_oi = group_oi, group_id = group_id, sender_oi = sender_oi, receiver_oi = receiver_oi, sample_id = sample_id, celltype_id_sender = celltype_id, celltype_id_receiver = celltype_id, prioritized_tbl_oi = prioritized_tbl_oi)
plot_list2$violin_group
plot_list2$violin_sample
```

## Zoom in on specific ligand-target interactions: show their expression in the single-cell data!

Make target gene violin and nebulosa plots: `make_target_violin_plot` and `make_target_nebulosa_feature_plot`

```{r}
receiver_oi = "Malignant"
group_oi = "High"

multinichenet_output$ligand_activities_targets_DEgenes$de_genes_df %>% inner_join(contrast_tbl) %>% filter(p_val <= 0.05) %>% filter(group == group_oi) %>% filter(receiver == receiver_oi) %>% arrange(p_val) %>% top_n(100, logFC)  
```

RAB31: interesting gene  

```{r, fig.width=18, fig.height=8}
target_oi = "RAB31"

make_target_violin_plot(seurat_obj_receiver = seurat_obj, target_oi = target_oi, receiver_oi = receiver_oi, group_oi = group_oi, group_id = group_id, sample_id, celltype_id_receiver = celltype_id, multinichenet_output$prioritization_tables$group_prioritization_tbl)
make_target_nebulosa_feature_plot(seurat_obj_receiver = seurat_obj, target_oi = target_oi, group_oi = group_oi, group_id = group_id, celltype_id_receiver = celltype_id, receivers_oi = c("Malignant","myofibroblast","CAF"), multinichenet_output$prioritization_tables$group_prioritization_tbl) 

```

## Make Dotplot for all DE genes/targets

Note: DE here determined based on the parameters used for the MultiNicheNet analysis (cf above): this means that DE genes are here not based on the p-value corrected for multiple testing!

```{r}
receiver_oi = "Malignant"
group_oi = "High"

targets_oi = multinichenet_output$ligand_activities_targets_DEgenes$de_genes_df %>% inner_join(contrast_tbl) %>% filter(group == group_oi) %>% arrange(p_val) %>% filter(receiver == receiver_oi) %>% pull(gene) %>% unique()

```

```{r, fig.width=8, fig.height=30}
p_target = make_sample_target_plots(receiver_info = multinichenet_output$celltype_info, targets_oi, receiver_oi, multinichenet_output$grouping_tbl)
p_target + ggtitle(paste0("DE genes in ",group_oi, " in celltype ",receiver_oi))
```

# Ligand-Target inference based on correlation and prior information

```{r}
return_lr_prod_matrix = TRUE
if(return_lr_prod_matrix == TRUE){

  ids_oi = prioritization_tables$group_prioritization_tbl %>% dplyr::filter(fraction_expressing_ligand_receptor > 0)  %>% dplyr::pull(id) %>% unique()
  
  lr_prod_df = abundance_expression_info$sender_receiver_info$avg_df %>% dplyr::inner_join(grouping_tbl, by = "sample") %>% dplyr::mutate(lr_interaction = paste(ligand, receptor, sep = "_")) %>% dplyr::mutate(id = paste(lr_interaction, sender, receiver, sep = "_")) %>% dplyr::select(sample, id, ligand_receptor_prod) %>% dplyr::filter(id %in% ids_oi) %>% dplyr::distinct() %>% tidyr::spread(id, ligand_receptor_prod)
  lr_prod_mat = lr_prod_df %>% dplyr::select(-sample) %>% data.frame() %>% as.matrix()
  rownames(lr_prod_mat) = lr_prod_df$sample
  
  col_remove = lr_prod_mat %>% apply(2,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
  row_remove = lr_prod_mat %>% apply(1,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
  
  lr_prod_mat = lr_prod_mat %>% .[rownames(.) %>% generics::setdiff(col_remove),colnames(.) %>% generics::setdiff(col_remove)]
} else {
  lr_prod_mat = NULL
}


```

# function
# per receiver --> table as output
# lapply over receivers --> bind_rows of the tables
# non-significant correlation --> set cor score to 0 --> prior score can still be shown as before, but with circle size of 0: no significant correlation

```{r}
lr_target_pior_cor_inference = function(receivers_oi, abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, p_val_adj, p_val_threshold, logFC_threshold, ligand_target_matrix){
    
  # Step1: calculate LR prod matrix
  ids_oi = prioritization_tables$group_prioritization_tbl %>% dplyr::filter(fraction_expressing_ligand_receptor > 0)  %>% dplyr::pull(id) %>% unique()

  # make ligand-receptor-id mapping
  lig_rec_send_rec_mapping = abundance_expression_info$sender_receiver_info$avg_df %>% dplyr::inner_join(grouping_tbl, by = "sample") %>% dplyr::mutate(lr_interaction = paste(ligand, receptor, sep = "_")) %>% dplyr::mutate(id = paste(lr_interaction, sender, receiver, sep = "_")) %>% dplyr::select(sender, receiver, ligand, receptor, id) %>% dplyr::distinct()
  
  # make receiver-id mapping to filter later on
  receiver_lr_id_mapping = abundance_expression_info$sender_receiver_info$avg_df %>% dplyr::inner_join(grouping_tbl, by = "sample") %>% dplyr::mutate(lr_interaction = paste(ligand, receptor, sep = "_")) %>% dplyr::mutate(id = paste(lr_interaction, sender, receiver, sep = "_")) %>% dplyr::select(receiver, sample, id, ligand_receptor_prod) %>% dplyr::filter(id %in% ids_oi) %>% dplyr::distinct(receiver, id) 
  
  # make LR prod matrix
  lr_prod_df = abundance_expression_info$sender_receiver_info$avg_df %>% dplyr::inner_join(grouping_tbl, by = "sample") %>% dplyr::mutate(lr_interaction = paste(ligand, receptor, sep = "_")) %>% dplyr::mutate(id = paste(lr_interaction, sender, receiver, sep = "_")) %>% dplyr::select(sample, id, ligand_receptor_prod) %>% dplyr::filter(id %in% ids_oi) %>% dplyr::distinct() %>% tidyr::spread(sample, ligand_receptor_prod)
  lr_prod_mat = lr_prod_df %>% dplyr::select(-id) %>% data.frame() %>% as.matrix()
  
  rownames(lr_prod_mat) = lr_prod_df$id
    
  col_remove = lr_prod_mat %>% apply(2,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
  row_remove = lr_prod_mat %>% apply(1,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
    
  lr_prod_mat = lr_prod_mat %>% .[rownames(.) %>% generics::setdiff(col_remove),colnames(.) %>% generics::setdiff(col_remove)]
  
  lr_prod_mat = lr_prod_mat[receiver_lr_id_mapping$id, ]
  
  # Step2: per receiver: subset lr_prod_mat, get DE genes, calculate correlation between LR and Target expression
  lr_target_cor = receivers_oi %>% lapply(function(receiver_oi){
    
    # subset lr_prod_mat
    lr_prod_mat_oi = lr_prod_mat[receiver_lr_id_mapping %>% dplyr::filter(receiver == receiver_oi) %>% dplyr::pull(id) %>% generics::intersect(rownames(lr_prod_mat)),]

    # get DE genes
    if(p_val_adj == FALSE){
      targets_oi = celltype_de %>% dplyr::filter(cluster_id == receiver_oi) %>% dplyr::filter(p_val <= p_val_threshold & logFC >= logFC_threshold) %>% dplyr::pull(gene)
    } else {
      targets_oi = celltype_de %>% dplyr::filter(cluster_id == receiver_oi) %>% dplyr::filter(p_adj <= p_val_threshold & logFC >= logFC_threshold) %>% dplyr::pull(gene)
    }
    
    avg_df =  abundance_expression_info$celltype_info$avg_df %>% dplyr::filter(gene %in% targets_oi & celltype %in% receiver_oi)
    
    target_df = avg_df %>% dplyr::select(sample, gene, average_sample) %>% dplyr::distinct() %>% tidyr::spread(sample, average_sample)
    target_mat = target_df %>% dplyr::select(-gene) %>% data.frame() %>% as.matrix()
    
    rownames(target_mat) = target_df$gene
      
    col_remove = target_mat %>% apply(2,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
    row_remove = target_mat %>% apply(1,function(x)sum(x != 0)) %>% .[. == 0] %>% names()
      
    target_mat = target_mat %>% .[rownames(.) %>% generics::setdiff(col_remove),colnames(.) %>% generics::setdiff(col_remove)]
    
    target_mat = target_mat[targets_oi, ]
    
    #  calculate correlation between LR and Target expression
    
    # pearson
    cor_mat = Hmisc::rcorr(lr_prod_mat_oi %>% t(), target_mat %>% t())
    
    cor_df_pearson = cor_mat$r %>% .[,rownames(target_mat)] %>% data.frame() %>% tibble::rownames_to_column("id") %>% tidyr::gather(target, pearson, -id) %>% tibble::as_tibble()
    cor_df_pearson_pval = cor_mat$P %>% .[,rownames(target_mat)] %>% data.frame() %>% tibble::rownames_to_column("id") %>% tidyr::gather(target, pearson_pval, -id) %>% tibble::as_tibble()

    # spearman
    cor_mat = Hmisc::rcorr(lr_prod_mat_oi %>% t(), target_mat %>% t(), type = "spearman")
    
    cor_df_spearman = cor_mat$r %>% .[,rownames(target_mat)] %>% data.frame() %>% tibble::rownames_to_column("id") %>% tidyr::gather(target, spearman, -id) %>% tibble::as_tibble()
    cor_df_spearman_pval = cor_mat$P %>% .[,rownames(target_mat)] %>% data.frame() %>% tibble::rownames_to_column("id") %>% tidyr::gather(target, spearman_pval, -id) %>% tibble::as_tibble()
    
    
    cor_df = lig_rec_send_rec_mapping %>% dplyr::inner_join(cor_df_pearson) %>% dplyr::inner_join(cor_df_pearson_pval) %>% dplyr::inner_join(cor_df_spearman) %>% dplyr::inner_join(cor_df_spearman_pval)

    # scaling of the correlation metric
    # cor_df = cor_df %>% group_by(id) %>% mutate(scaled_pearson = nichenetr::scale_quantile(pearson, 0.05)) %>% group_by(target) %>% mutate(scaled_target_pearson = nichenetr::scale_quantile(pearson, 0.05)) # is this double scaling necessary? I could use this later
    cor_df = cor_df %>% dplyr::ungroup() %>% dplyr::mutate(scaled_pearson = nichenetr::scale_quantile(pearson, 0.05), scaled_spearman = nichenetr::scale_quantile(spearman, 0.05))  # is this double scaling necessary? I could use this later

  }) %>% bind_rows()
  
  # Step3: Scale the ligand-target prior information scores 
  ligand_target_df = ligand_target_matrix %>% data.frame() %>% tibble::rownames_to_column("target") %>% tidyr::gather(ligand, prior_score, -target) %>% tibble::as_tibble()
  ligand_target_df = ligand_target_df %>% dplyr::group_by(ligand) %>% dplyr::mutate(scaled_ligand = nichenetr::scale_quantile(prior_score, 0.0005)) %>% dplyr::group_by(target) %>% dplyr::mutate(scaled_target = nichenetr::scale_quantile(prior_score, 0.0005))
  ligand_target_df = ligand_target_df %>% dplyr::mutate(scaled_prior_score = 0.5*(scaled_ligand + scaled_target))

  # Step4: Combine the ligand-target prior information scores and combine with the correlation based ones!
  cor_prior_df = lr_target_cor %>% dplyr::inner_join(ligand_target_df) %>% dplyr::mutate(id_target = paste(id, target, sep = "_")) %>% dplyr::ungroup() 
  # cor_prior_df = cor_prior_df %>% mutate(scaled_cor_score = 0.5*(scaled_pearson + scaled_target_pearson ))
  # cor_prior_df = cor_prior_df %>% mutate(final_score = 0.50*(2*scaled_prior_score + scaled_cor_score)) %>% arrange(-final_score)
  cor_prior_df = cor_prior_df %>% dplyr::mutate(final_score = (scaled_prior_score + 0.50*scaled_pearson + 0.50*scaled_spearman)/2) %>% dplyr::arrange(-final_score) # I could give more weight to the prior information? - but maybe do not do this for the moment?

}

lr_target_prior_cor = lr_target_pior_cor_inference(receivers_oi = prioritization_tables$group_prioritization_tbl$receiver %>% unique(), abundance_expression_info, celltype_de, grouping_tbl, prioritization_tables, p_val_adj , p_val_threshold, logFC_threshold, ligand_target_matrix)
```

```{r}
# only add multiple testing correction later
# add multiple testing correction on the correlation values - put the correlation to zero if the adjusted p-value is not significant - # maybe not necessary - open to change for later on!
# lr_target_cor = lr_target_cor %>% mutate(padj_pearson = p.adjust(pearson_pval, "BH"))
# lr_target_cor$pearson[lr_target_cor$padj_pearson > 0.05] = 0
# lr_target_cor$scaled_pearson[lr_target_cor$padj_pearson > 0.05] = 0
```


```{r}
group_oi = "High"
receiver_oi = "Malignant"
```

```{r, fig.height=10, fig.width=15}
prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  distinct(id, ligand, receptor, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_expressing_ligand_receptor,  prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0) %>% 
  filter(group == group_oi) %>% group_by(group) %>% top_n(250, prioritization_score) 

if(p_val_adj == FALSE){
    targets_oi = grouping_tbl %>% inner_join(contrast_tbl) %>% inner_join(celltype_de) %>% filter(cluster_id == receiver_oi) %>% filter(p_val <= p_val_threshold & logFC >= logFC_threshold) %>% filter(group == group_oi) %>% pull(gene)
  } else {
    targets_oi = grouping_tbl %>% inner_join(contrast_tbl) %>% inner_join(celltype_de) %>% filter(cluster_id == receiver_oi) %>% filter(p_adj <= p_val_threshold & logFC >= logFC_threshold) %>% filter(group == group_oi) %>% pull(gene)
  }
  
lr_target_pior_cor_filtered = lr_target_prior_cor %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% mutate(padj_pearson = p.adjust(pearson_pval, "BH"), padj_spearman = p.adjust(spearman_pval, "BH"))

lr_target_pior_cor_filtered %>% filter(padj_pearson <= 0.10 & scaled_prior_score > 0.45 & pearson > 0) %>% ggplot(aes(target, id, fill = scaled_prior_score)) + geom_tile() 

lr_target_pior_cor_filtered %>% filter(padj_pearson <= 0.10 | padj_spearman <= 0.10) %>% filter(scaled_prior_score > 0.50 & pearson > 0 & spearman > 0) %>% ggplot(aes(target, id, fill = scaled_prior_score)) + geom_tile() 


lr_target_pior_cor_filtered %>% filter(scaled_prior_score > 0.50 & (pearson > 0.25 | spearman > 0.25) ) %>% 
  ggplot(aes(target, id, color = scaled_prior_score, size = pearson)) + geom_point() 

lr_target_pior_cor_filtered %>% filter(padj_pearson <= 0.10 & scaled_prior_score > 0.45 & pearson > 0) %>% 
  ggplot(aes(target, id, fill = prior_score)) + geom_tile() 



# lr_target_pior_cor %>% filter(scaled_pearson > 0.66 & scaled_prior_score > 0.66) %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% 
#   ggplot(aes(target, id, color = scaled_prior_score, size = pearson)) + geom_point() 
# lr_target_pior_cor %>% filter(padj_pearson <= 0.10) %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% 
#   ggplot(aes(target, id, color = scaled_prior_score, size = pearson)) + geom_point() 
# 
# lr_target_pior_cor %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% 
#   ggplot(aes(target, id, color = pearson, size = scaled_prior_score)) + geom_point() # by changing the color and size mappings, a beautiful figure might be coming out...

```


```{r, fig.height=12, fig.width=12}
group_oi = "High"

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  distinct(id, ligand, receptor, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_expressing_ligand_receptor,  prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0 & ligand_receptor_lfc_avg > 0) %>% 
  filter(group == group_oi) %>% group_by(group) %>% top_n(250, prioritization_score) 
# lr_target_pior_cor_oi = lr_target_pior_cor %>% filter(scaled_pearson > 0.66 & scaled_prior_score > 0.66) 
# lr_target_pior_cor_oi = lr_target_pior_cor %>% filter(scaled_pearson > 0.66 & scaled_prior_score > 0.66) %>% filter(id %in% prioritized_tbl_oi$id)
lr_target_prior_cor = lr_target_prior_cor %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% mutate(padj_pearson = p.adjust(pearson_pval, "BH"), padj_spearman = p.adjust(spearman_pval, "BH"))

lr_target_pior_cor_filtered = lr_target_prior_cor %>% filter(scaled_prior_score > 0.60 & (pearson > 0.50 & spearman > 0.50))
# lr_target_pior_cor_oi = lr_target_pior_cor_oi %>% filter(scaled_prior_score > 0.50 & padj_pearson <= 0.10)

# lr_target_pior_cor_oi = lr_target_pior_cor_filtered %>% filter(scaled_prior_score > 0.60 & (padj_pearson <= 0.10 | padj_spearman < 0.10))

make_ggraph_ligand_target_links = function(lr_target_pior_cor_filtered, colors){
    source_df = lr_target_pior_cor_oi %>% mutate(celltype_ligand = paste(sender, ligand, sep = "_"), celltype_target = paste(receiver, target, sep = "_"), celltype_receptor = paste(receiver, receptor, sep = "_")) %>% select(sender, receiver, celltype_ligand, celltype_receptor, celltype_target, ligand, target, receptor) 
  
  lr_gr_network = source_df %>% filter(celltype_target %in% c(source_df$celltype_ligand, source_df$celltype_receptor)) 
  ligand_receptor_network = lr_gr_network %>% filter(celltype_receptor %in% celltype_target) %>% select(celltype_ligand, celltype_receptor) %>% distinct() %>% rename(sender = celltype_ligand, receiver = celltype_receptor) %>% mutate(type = "Ligand-Receptor", weight = 1)
  ligand_target_network = lr_gr_network %>% select(celltype_ligand, celltype_target) %>% distinct() %>% rename(sender = celltype_ligand, receiver = celltype_target) %>% mutate(type = "Ligand-Target", weight = 1)
  
  links = ligand_target_network %>% bind_rows(ligand_receptor_network) 
  nodes = lr_gr_network %>% select(celltype_ligand, sender, ligand) %>% rename(celltype = sender, node = celltype_ligand, gene = ligand)  %>% bind_rows(
    lr_gr_network %>% select(celltype_receptor, receiver, receptor) %>% rename(celltype = receiver, node = celltype_receptor, gene = receptor)
  ) %>% bind_rows(
    lr_gr_network %>% select(celltype_target, receiver, target) %>% rename(celltype = receiver, node = celltype_target, gene = target)
  ) %>% distinct() %>% filter(node %in% c(links$sender, links$receiver))
  nodes = nodes %>% data.frame() %>% magrittr::set_rownames(nodes$node)
  
  # create the network object
  network <- igraph::graph_from_data_frame(d=links %>% filter(type == "Ligand-Target"), vertices = nodes, directed=T)
  graph <- tidygraph::as_tbl_graph(network) 
  set.seed(1919)
  plot = suppressWarnings(ggraph::ggraph(graph, layout = 'dh') + 
      geom_edge_elbow(edge_width = 1.15, color = "gray25", arrow = arrow(length = unit(4, 'mm')), end_cap = circle(4.5, 'mm'), start_cap = circle(3.5, 'mm')) +
      geom_edge_loop(edge_width = 1, alpha = 0.70, color = "gray25") + 
      # geom_node_point(aes(color = celltype), size = 3.5, alpha = 0.50) +
      geom_node_label(aes(label = gene, color = celltype), fontface = "bold", size = 3.5, nudge.x = 0, nudge.y = 0) +
      # geom_node_text(aes(label = gene, color = celltype), fontface = "bold", size = 4) +
      theme_graph(foreground = 'black', fg_text_colour = 'white') + scale_color_manual(values = colors))
  
  return(list(plot = plot, graph = graph))
}

graph_plot = make_ggraph_ligand_target_links(lr_target_pior_cor_filtered = lr_target_pior_cor_filtered, colors = colors_sender)
graph_plot$plot



```

New visualization of ligand-receptor links, and then the ligand-target matrix, and then the target expression
```{r}
group_oi = "High"
receiver_oi = "Malignant"

prioritized_tbl_oi = multinichenet_output$prioritization_tables$group_prioritization_tbl %>% 
  distinct(id, ligand, receptor, sender, receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity_scaled, fraction_expressing_ligand_receptor,  prioritization_score) %>% 
  filter(fraction_expressing_ligand_receptor > 0 & ligand_receptor_lfc_avg > 0) %>% 
  filter(group == group_oi & receiver == receiver_oi) %>% group_by(group) %>% top_n(250, prioritization_score) 
# lr_target_pior_cor_oi = lr_target_pior_cor %>% filter(scaled_pearson > 0.66 & scaled_prior_score > 0.66) 
# lr_target_pior_cor_oi = lr_target_pior_cor %>% filter(scaled_pearson > 0.66 & scaled_prior_score > 0.66) %>% filter(id %in% prioritized_tbl_oi$id)
lr_target_prior_cor = lr_target_prior_cor %>% filter(id %in% prioritized_tbl_oi$id & target %in% targets_oi) %>% mutate(padj_pearson = p.adjust(pearson_pval, "BH"), padj_spearman = p.adjust(spearman_pval, "BH"))

lr_target_pior_cor_filtered = lr_target_prior_cor %>% filter(scaled_prior_score > 0.60 & (pearson > 0.50 & spearman > 0.50))

prioritized_tbl_oi = prioritized_tbl_oi %>% filter(id %in% lr_target_pior_cor_filtered$id)

# multinichenet_output$ligand_activities_targets_DEgenes
# contrast_tbl, multinichenet_output$grouping_tbl, 
receiver_info = multinichenet_output$celltype_info

make_lr_target_correlation_plot = function(prioritization_tables, prioritized_tbl_oi, contrast_tbl, grouping_tbl, receiver_info, plot_legend = TRUE, heights = NULL, widths = NULL){
  
  ##### LR product plot
  sample_data = prioritization_tables$sample_prioritization_tbl %>% dplyr::filter(id %in% prioritized_tbl_oi$id) %>% dplyr::mutate(sender_receiver = paste(sender, receiver, sep = " to ")) %>%  dplyr::arrange(sender) %>% dplyr::group_by(sender) %>%  dplyr::arrange(receiver)
  
    group_data = prioritization_tables$group_prioritization_tbl %>% dplyr::mutate(sender_receiver = paste(sender, receiver, sep = " to ")) %>% dplyr::distinct(id, sender, receiver, sender_receiver, lr_interaction, group, ligand_receptor_lfc_avg, activity, activity_scaled, fraction_ligand_group, prioritization_score, scaled_avg_exprs_ligand) %>% dplyr::filter(id %in% sample_data$id)
  
    keep_sender_receiver_values = c(0.25, 0.9, 1.75, 4)
    names(keep_sender_receiver_values) = levels(sample_data$keep_sender_receiver)
    
    sample_data = sample_data %>% mutate(sample = factor(sample)) %>% mutate(sample = factor(sample, levels = rev(levels(sample)))) # reverse - to have the same order as used for the targets
    
    p1 = sample_data %>%
      ggplot(aes(sample, lr_interaction, color = scaled_LR_prod, size = keep_sender_receiver)) +
      geom_point() +
      facet_grid(sender_receiver~group, scales = "free", space = "free", switch = "y") +
      scale_x_discrete(position = "top") +
      # xlab("Ligand-Receptor expression in samples\n\n") +
      theme_light() +
      theme(
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        # axis.title.x = element_text(face = "bold", size = 11),       axis.title.y = element_blank(),
        axis.text.y = element_text(face = "bold.italic", size = 9),
        axis.text.x = element_text(size = 9,  angle = 90,hjust = 0),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.spacing.x = unit(0.40, "lines"),
        panel.spacing.y = unit(0.25, "lines"),
        strip.text.x.top = element_text(size = 10, color = "black", face = "bold", angle = 0),
        strip.text.y.left = element_text(size = 9, color = "black", face = "bold", angle = 0),
        strip.background = element_rect(color="darkgrey", fill="whitesmoke", size=1.5, linetype="solid")
      ) + labs(color = "Scaled L-R\navg expression product", size= "Sufficient presence\nof sender & receiver") + 
      scale_size_manual(values = keep_sender_receiver_values)
    max_lfc = abs(sample_data$scaled_LR_prod) %>% max()
    custom_scale_color = scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 7, name = "RdBu") %>% rev(),values = c(0, 0.350, 0.4850, 0.5, 0.5150, 0.65, 1),  limits = c(-1*max_lfc, max_lfc))
  
    p_lr_exprs = p1 + custom_scale_color
  
##### LR-->Target plot
  
  lr_target_data = lr_target_pior_cor_filtered %>% inner_join(sample_data) %>% select(id, lr_interaction, sender_receiver, group, target, scaled_prior_score, final_score, prior_score, pearson) %>% distinct()
  lr_target_data = lr_target_data %>% mutate(target = factor(target))
  order_targets = lr_target_data$target %>% levels()
  lr_target_data_filled = lr_target_data %>% distinct(id, target, scaled_prior_score) %>% tidyr::spread(target, scaled_prior_score, fill = 0) %>% tidyr::gather(target, score, -id)
  lr_target_data = lr_target_data_filled %>% inner_join(lr_target_data %>% select(id, lr_interaction, sender_receiver, group))

  p2 = lr_target_data %>%
    ggplot(aes(target, lr_interaction, fill = score)) +
    geom_tile(color = "gray75") +
    facet_grid(sender_receiver~., scales = "free", space = "free", switch = "y") +
    scale_x_discrete(position = "top") +
    # xlab("Ligand-Receptor expression in samples\n\n") +
    theme_light() +
    theme(
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      # axis.title.x = element_text(face = "bold", size = 11),       axis.title.y = element_blank(),
      axis.text.y = element_text(face = "bold.italic", size = 9),
      axis.text.x = element_text(size = 9,  angle = 90,hjust = 0),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.spacing.x = unit(0.40, "lines"),
      panel.spacing.y = unit(0.25, "lines"),
      strip.text.x.top = element_text(size = 10, color = "black", face = "bold", angle = 0),
      strip.text.y.left = element_text(size = 9, color = "black", face = "bold", angle = 0),
      strip.background = element_rect(color="darkgrey", fill="whitesmoke", size=1.5, linetype="solid")
    ) + labs(fill = "Prior knowledge score\nof correlated targets") 
  custom_scale_fill = scale_fill_gradientn(colours = c("white", RColorBrewer::brewer.pal(n = 7, name = "BuPu")) ,values = c(0, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 1),  limits = c(0, 1))

  p_lr_target = p2 + custom_scale_fill

##### Target expression plot
  # Target expression
  groups_oi = group_data %>% dplyr::pull(group) %>% unique()
  p_target_exprs = make_sample_target_plots_reversed(receiver_info, order_targets, receiver_oi, grouping_tbl %>% dplyr::filter(group %in% groups_oi))

  #### now combine all three plots
   # Combine the plots
  n_targets = length(order_targets)
  n_ligands = length(lr_target_data$id %>% unique())
  n_samples = grouping_tbl %>% dplyr::filter(group %in% groups_oi) %>% dplyr::pull(sample) %>% length()

  legends = patchwork::wrap_plots(ggpubr::as_ggplot(ggpubr::get_legend(p_lr_exprs)), ggpubr::as_ggplot(ggpubr::get_legend(p_lr_target)), nrow = 2) %>%
    patchwork::wrap_plots(ggpubr::as_ggplot(ggpubr::get_legend(p_target_exprs)))

  if(is.null(heights)){
    heights = c(n_ligands, n_samples)
  }
  if(is.null(widths)){
    widths = c(n_samples, n_targets)
  }

  if(plot_legend == FALSE){
    design <- "AB
               #C"
    combined_plot = patchwork::wrap_plots(A = p_lr_exprs + theme(legend.position = "none", axis.ticks = element_blank()) + theme(axis.title.x = element_text()),
                                          B = p_lr_target + theme(legend.position = "none", axis.ticks = element_blank()) + ylab(""),
                                          C = p_target_exprs + theme(legend.position = "none"),
                                          nrow = 2, design = design, widths = widths, heights = heights)
    return(list(combined_plot = combined_plot, legends = legends))

  } else {
    design <- "AB
               LC"

    combined_plot = patchwork::wrap_plots(A = p_lr_exprs + theme(legend.position = "none", axis.ticks = element_blank()) + theme(axis.title.x = element_text()),
                                          
                                          B = p_lr_target + theme(legend.position = "none", axis.ticks = element_blank()) + ylab(""),
                                          C = p_target_exprs + theme(legend.position = "none"),
                                          L = legends, nrow = 2, design = design, widths = widths, heights = heights)
    return(list(combined_plot = combined_plot, legends = legends))
  }

  
}  

lr_target_cor_plot = make_lr_target_correlation_plot(multinichenet_output$prioritization_tables, prioritized_tbl_oi, contrast_tbl, multinichenet_output$grouping_tbl, multinichenet_output$celltype_info, plot_legend = FALSE)

```


## References
